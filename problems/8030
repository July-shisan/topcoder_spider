<td class="problemText" valign="middle" align="left">
                      
              		<table><tr><td colspan="2" class="statText"><h3>Problem Statement</h3></td></tr><tr><td class="statText">    </td><td class="statText"><p>A binary power bishop is at point (0, 0) and wants to get to point (<b>finishX</b>, <b>finishY</b>). In one move, the bishop can go from point (x, y) to any one of the following points: (x + 2<sup>k</sup>, y + 2<sup>k</sup>), (x + 2<sup>k</sup>, y - 2<sup>k</sup>), (x - 2<sup>k</sup>, y + 2<sup>k</sup>), (x - 2<sup>k</sup>, y - 2<sup>k</sup>), where k is any non-negative integer. The only restriction on the bishop's moves is that all of them must have distinct values of k.</p>

<p>Return a String[] describing the path of the bishop from (0, 0) to (<b>finishX</b>, <b>finishY</b>) that contains the minimum possible number of moves.  The elements of the return should describe all the points visited by the bishop, in order, including the start and end points.  Each element should describe a single point (x, y) in the format "x,y" (quotes for clarity).  If there are multiple possible return values, return the one that comes first lexicographically.  If it is impossible to reach the finish point, return an empty String[] instead.</p></td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Definition</h3></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText">Class:</td><td class="statText">BinaryPowerBishop</td></tr><tr><td class="statText">Method:</td><td class="statText">getPath</td></tr><tr><td class="statText">Parameters:</td><td class="statText">int, int</td></tr><tr><td class="statText">Returns:</td><td class="statText">String[]</td></tr><tr><td class="statText">Method signature:</td><td class="statText">String[] getPath(int finishX, int finishY)</td></tr><tr><td colspan="2" class="statText">(be sure your method is public)</td></tr></table></td></tr><tr><td class="statText">    </td></tr><tr><td class="statText"></td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Notes</h3></td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">A String[] <i>A</i> comes before a String <i>B</i> lexicographically if <i>A</i> has a lexicographically smaller String at the first index at which they differ. A String <i>A</i> comes before a String <i>B</i> lexicographically if <i>A</i> is a proper prefix of <i>B</i>, or if <i>A</i> has a smaller character at the first position where the strings differ. When comparing the characters, refer to the following list of characters in ascending order: ',', '-', '0', '1', ..., '9'.</td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>finishX</b> and <b>finishY</b> will each be between 1 and 100000000, inclusive.</td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Examples</h3></td></tr><tr><td align="center" nowrap class="statText">0)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>16</pre></td></tr><tr><td class="statText"><pre>16</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: {"0,0", "16,16" }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">Only one move is needed.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">1)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>8</pre></td></tr><tr><td class="statText"><pre>24</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: {"0,0", "-8,8", "8,24" }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">Here two moves is enough. Note that the bishop can visit points with negative coordinates.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">2)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>11</pre></td></tr><tr><td class="statText"><pre>22</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: { }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">If the bishop moves from (x1, y1) to (x2, y2), the parities of the sums x1+y1 and x2+y2 are the same.  Therefore, the bishop can't visit any point (x, y) with an odd sum x+y.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">3)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>123</pre></td></tr><tr><td class="statText"><pre>321</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: 
{"0,0",
"-128,128",
"-112,112",
"-104,104",
"-100,100",
"-102,98",
"-101,97",
"-133,65",
"123,321" }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText"></td></tr></table></td></tr></table></td></tr></table><hr><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2010, TopCoder, Inc.  All rights reserved.  </p>
                      
                   </td>